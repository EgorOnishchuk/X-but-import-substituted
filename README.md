# Tweeter (X) — импортозамещённая версия популярной соцсети

## Из этого руководства Вы узнаете:

1. Как быстро начать работу — запустить проект «из коробки»
2. Как использовать продвинутую конфигурацию (требуются знания из ч. 1)

## Быстрый старт

Установка предельно проста:

```bash
git clone gitlab.skillbox.ru/egor_onishchuk/python_advanced_diploma
```

После клонирования репозитория Вам необходимо создать файл **.env** в корне проекта по шаблону из **.env.template**. 
Также клиентам могут потребоваться статические файлы: их можно разместить в папке **static**.
Далее — проверьте наличие актуальной версии **Docker** (настоятельно рекомендую воспользоваться 
[официальной инструкцией](https://docs.docker.com/engine/install/ "Документация Docker")). 

Хорошей практикой будет тестирование проекта перед каждым его развёртыванием — сделаем это:

```bash
docker compose --profile test up
```

> Не приступайте к следующим шагам, если хотя бы один из тестов будет провален, это может обернуться серьёзными 
> ошибками, в т.ч. «тихими» (например, бреши в безопасности, которые будут незаметны от Вас, но которыми могут 
> воспользоваться злоумышленники).

После прохождения всех проверок снова отредактируйте **.env** (если необходимо) и выполните самую важную команду:

```bash
docker compose --profile prod up
```

Теперь Ваш проект должен быть доступен по адресу http://localhost:<указанный порт>.

## Продвинутая конфигурация

Прежде чем дорабатывать модули приложения под себя следует кратко описать архитектуру. Моей целью было 
создание веб-сервиса, который:

* полностью соответствует идеологии _серверного MVC_
* разделён на слои _репозиторий — сервис — контроллер_
* совместим с различными _ORM_ и другими хранилищами данных
* не перегружен абстракциями: задачу сделать его полностью независимым от _FastAPI_ я не ставил

Рассмотрим два основных сценария написания собственной функциональности для нашего отечественного Твиттера.

### Как перейти на другое хранилище данных?

Перейдём к  **services.py**, расположенному в _src_: здесь находятся абстрактный репозиторий для БД и репозиторий 
_SQLAlchemy_ (основная ORM для проекта) с уже реализованным типовым функционалом для CRUD. В **schemas.py** и
**models.py** находятся _схемы_ (DTO) и _модели_ (также частично выполняют функцию DTO, т.к. приложение в основном 
ориентировано именно на CRUD) соответственно — основные объекты, перемещающиеся между разными слоями.

Сервисы в папках для каждой из сущностей следуют принципу _инверсии зависимостей_, а это значит, что для перехода на 
другое хранилище данных (например, SQLModel, TortoiseORM и т.д.) достаточно:

1. Создать нового наследника _DataModel_
2. Создать новый репозиторий
3. Изменить конфигурацию сервиса через _инъекцию зависимости_ FastAPI

Более того, хранилище может и не быть _реляционным_. Так сделано, например, для изображений, которые хранятся в 
файловой системе (**FileSystemMediaRepository** из _src/medias/services.py_).

### Как создать новую доменную модель?

Я рекомендую придерживаться такой файловой структуры, в которой каждой сущности API соответствует своя папка как минимум
с пятью файлами: маршрутизатор, службы (сюда входят сервисы и репозитории), схемы, модели и зависимости. Это позволяет в
будущем легче перейти с монолита на микросервисную архитектуру (шаблон _Strangler Fig_).

### Авторы

* [Егор Онищук](https://gitlab.skillbox.ru/egor_onishchuk "Профиль в GitLab") — разработка, тестирование и
  документирование
* [Skillbox](https://skillbox.ru/ "Платформа") — кураторство
